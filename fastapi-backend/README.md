# FastAPI Backend for Board Game DSL

This backend provides a generic game engine that runs board games defined using
the Xtext-based Board Game DSL (BGDSL).  
The backend is fully dynamic and supports **any number of `.bgdsl` files**
generated by the DSL compiler.

Games such as TicTacToe, Connect4, Othello, and custom board games work without
any backend changes.

---

# ğŸš€ Overview

The backend loads **auto-generated Python files** from the DSL compiler:

```app/generated/games/<game>.py (one per .bgdsl file)```
```app/generated/engine/models.py (shared Pydantic models, this will be the classes specified in the ECore model.)```


Each `<game>.py` file contains a statically defined game object with:
- board definition  
- tile placements  
- players  
- tile states and transitions  
- pipelines for legal moves and effects  

At runtime, the backend keeps track of:
- **active player**
- **current state of each tile**
- **move history** (optional)
- **turn switching**
- **legal moves** (from pipeline, coming soon)

This runtime state is held in an in-memory `GameStateManager`.

The frontend interacts with the game through **simple REST endpoints**.

---

# ğŸ“ Project Structure

fastapi-backend/
â”‚
â”œâ”€â”€ app/
â”‚ â”œâ”€â”€ main.py # FastAPI app startup
â”‚ â”œâ”€â”€ routers/
â”‚ â”‚ â”œâ”€â”€ game_state.py # GET /game-state
â”‚ â”‚ â””â”€â”€ moves.py # POST /move
â”‚ â”œâ”€â”€ services/
â”‚ â”‚ â”œâ”€â”€ game_manager.py # Stores active players + tile states
â”‚ â”‚ â””â”€â”€ legal_moves.py # (future) pipeline support
â”‚ â”œâ”€â”€ models/
â”‚ â”‚ â”œâ”€â”€ game_state_response.py
â”‚ â”‚ â””â”€â”€ move_request.py
â”‚ â”œâ”€â”€ generated/
â”‚ â”‚ â”œâ”€â”€ engine/models.py # Generated from DSL
â”‚ â”‚ â””â”€â”€ games/*.py # One game file per .bgdsl model
â”‚ â””â”€â”€ init.py
â”‚
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

# ğŸ”§ Running the Backend

Inside `fastapi-backend/`:

```
python -m venv venv
source venv/bin/activate   # Windows: venv\Scripts\activate
pip install -r requirements.txt

uvicorn app.main:app --reload
```

Server is now available at:

http://localhost:8000
http://localhost:8000/docs

# ğŸ® Supported Games
The backend automatically loads all games from: 
```
app/generated/games/
```

Games are available through: 
```
GET /games
```

Example response: 
```
["tictactoe", "connect4"]
```

The frontend can use this list to dynamically present available games.

# ğŸŸ¦ API Endpoints

## 1. List all games
```
GET /games
```
Returns all available game names.

### Response example:
```
["tictactoe", "connect4"]
```

## 2. Get full game state snapshots
```
GET /games/{game_name}/game-state
```

Returns the complete current state of the board and players.

This is the endpoint the frontend uses to:

- initialize the UI

- draw the board

- highlight legal moves

- refresh UI after a move

### Response example:

(tiles aren't correct considering boardwith and height is 3)
```
{
  "players": ["PlayerX", "PlayerO"],
  "activePlayer": "PlayerX",
  "boardWidth": 3,
  "boardHeight": 3,
  "tiles": [
    { "row":0, "column":0, "tileName":"Tile", "stateName":"Empty" },
    { "row":1, "column":1, "tileName":"Tile", "stateName":"X" } ...
  ],
  "legalMoves": [
    { "row":0, "column":0, "tileName":"Tile", "stateName":"Empty" }
  ]
}
```

## 3. Make a move
```
POST /games/{game_name}/move
```
The frontend calls this when the user clicks on a tile.
Request body:

```
{
  "player": "PlayerX",
  "row": 1,
  "column": 2
}
```

What the backend does:

Confirms it is the correct player's turn

Finds the tile at (row, column)

Reads its current state

Applies DSL-defined state transitions

Updates the tile state in memory

Advances the turn

Returns the updated /game-state

Response:

Same schema as GET /game-state.

