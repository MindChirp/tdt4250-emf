/*
 * generated by Xtext 2.39.0
 */
package no.ntnu.tdt4250.bg.bgdsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EStructuralFeature
import java.util.Set
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BgDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		//val models = resource.allCSontents
		
		val gameInstance = resource.contents.head as EObject
		val gameEClass = gameInstance.eClass
		
		val allUniqueEClasses = gameInstance.eAllContents.toIterable.map[eClass].toSet
		
		allUniqueEClasses.add(gameEClass)
        
        if (gameInstance === null) {
            System.err.println("Model resource is empty. Cannot generate data.")
            return;
        }
        
        System.out.println("Generating code with model instance data...")
        
        // 1a. Generate the Board file (Data-Specific)
        fsa.generateFile(
            "models" + ".py",
            allUniqueEClasses.compileModels(gameInstance)
        )
        
        // 1b. Generate all other structural classes (e.g., Tile)
        // Filter out the Board class and generate the structural blueprints.
        /*for (eClass : allUniqueEClasses.filter[it != gameEClass]) {
            fsa.generateFile(
                eClass.name + ".py",
                eClass.compileStructural
            )
        }*/
        
  
	}
	
	def compileModels(Set<EClass> models, EObject gameInstance)
'''
from typing import List, Optional
from pydantic import BaseModel

Â«FOR model : modelsÂ»
class Â«model.nameÂ»(BaseModel):
	Â«IF model.EAllStructuralFeatures.emptyÂ»
	pass
	Â«ELSEÂ»
	Â«FOR field : model.EAllStructuralFeaturesÂ»
Â«field.toPythonFieldDecÂ»
	Â«ENDFORÂ»
	Â«ENDIFÂ»

Â«ENDFORÂ»
Â«FOR model : modelsÂ»
Â«model.nameÂ».model_rebuild()
Â«ENDFORÂ»

Â«initializeValues(gameInstance)Â»
'''


def initializeValues(EObject gameInstance) {
	val boardInstance = gameInstance.eGet(gameInstance.eClass.getEStructuralFeature("board")) as EObject
	
	val tileTypes = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("tiles")) as EList<EObject>
	val tilePlacements = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("tilePlacement")) as EList<EObject>
	

	// ??? vi har vel ikke en game class (?) sÃ¥ idk hvordan vi skal finne ut hvor mange players vi har
	val players = gameInstance.eGet(gameInstance.eClass.getEStructuralFeature("players")) as EList<EObject>
	
	val turnPolicy = gameInstance.eGet(gameInstance.eClass.getEStructuralFeature("turnPolicy")) as EList<EObject>

'''
Â«FOR tileType : tileTypesÂ»
	Â«val tileName = tileType.eGet(tileType.eClass.getEStructuralFeature("name"))Â»
    Â«val initState = tileType.eGet(tileType.eClass.getEStructuralFeature("initialState"))as EObjectÂ»
    Â«val initName = initState.eGet(initState.eClass.getEStructuralFeature("name"))Â»
    Â«val initColor = initState.eGet(initState.eClass.getEStructuralFeature("hexColor"))Â»


class Â«tileNameÂ»():
	stateÂ«initNameÂ» = State(
	    name="Â«initNameÂ»",
	    hexColor="Â«initColorÂ»",
	    outbound=[]
	)
	
	    Â«FOR state : tileType.eGet(tileType.eClass.getEStructuralFeature("states")) as EList<EObject>Â»
	        Â«val sName = state.eGet(state.eClass.getEStructuralFeature("name"))Â»
	stateÂ«sNameÂ» = State(
	    name="Â«sNameÂ»",
	    hexColor="#ffffff",
	    outbound=[],
	    inbound=[]
	)
	    Â«ENDFORÂ»
	
	    Â«FOR transition : tileType.eGet(tileType.eClass.getEStructuralFeature("transitions")) as EList<EObject>Â»
	        Â«val tName = transition.eGet(transition.eClass.getEStructuralFeature("name"))Â»
	        
	        Â«val rawSources = transition.eGet(transition.eClass.getEStructuralFeature("source")) as EList<EObject>Â»
	                Â«val srcList = rawSources.toSet()Â»
	transitionÂ«tNameÂ» = Transition(
	    source=[
	        Â«FOR src : srcList SEPARATOR ", "Â»
	            stateÂ«src.eGet(src.eClass.getEStructuralFeature("name"))Â»
	        Â«ENDFORÂ»
	    ],
	    Â«val target = transition.eGet(transition.eClass.getEStructuralFeature("target")) as EObjectÂ»
	    target=stateÂ«target.eGet(target.eClass.getEStructuralFeature("name"))Â»
	)
	
	    Â«ENDFORÂ»
	Â«FOR transition : tileType.eGet(tileType.eClass.getEStructuralFeature("transitions")) as EList<EObject>Â»
	        Â«val tName = transition.eGet(transition.eClass.getEStructuralFeature("name"))Â»
	        
	        Â«val rawSources = transition.eGet(transition.eClass.getEStructuralFeature("source")) as EList<EObject>Â»
	        Â«val srcList = rawSources.toSet()Â»
	        
	        Â«FOR src : srcListÂ»
	stateÂ«src.eGet(src.eClass.getEStructuralFeature("name"))Â».outbound += transitionÂ«tNameÂ»
	        Â«ENDFORÂ»
	        Â«val target = transition.eGet(transition.eClass.getEStructuralFeature("target")) as EObjectÂ»
	stateÂ«target.eGet(target.eClass.getEStructuralFeature("name"))Â».inbound += transitionÂ«tNameÂ»
	    Â«ENDFORÂ»
	Â«ENDFORÂ»


tileplacements=[
	Â«FOR tilePlacement : tilePlacements SEPARATOR ", "Â»
		Â«val tilePlacementRow = tilePlacement.eGet(tilePlacement.eClass.getEStructuralFeature("row")) as IntegerÂ»
		Â«val tilePlacementColumn = tilePlacement.eGet(tilePlacement.eClass.getEStructuralFeature("column")) as IntegerÂ»
		
		Â«val tilePlacementType = tilePlacement.eGet(tilePlacement.eClass.getEStructuralFeature("tile")) as EObjectÂ»
		Â«val tilePlacementTypeName = tilePlacementType.eGet(tilePlacementType.eClass.getEStructuralFeature("name")) as StringÂ»
		
		
		Â«val tilePlacementDarker = tilePlacement.eGet(tilePlacement.eClass.getEStructuralFeature("darker")) as BooleanÂ»
		Â«val tilePlacementCoordinate = tilePlacement.eGet(tilePlacement.eClass.getEStructuralFeature("coordinate")) as StringÂ»
	TilePlacement(Â«tilePlacementRowÂ», Â«tilePlacementColumnÂ», Â«tilePlacementTypeNameÂ»(), Â«tilePlacementDarkerÂ», Â«tilePlacementCoordinateÂ»)
	Â«ENDFORÂ»
]
'''
	
}

def generateBoard(EObject boardInstance) {
	// Board
	val width = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("width")) as Integer
    val height = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("height")) as Integer
    val checkered = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("checkered")) as Boolean
    val size = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("size")) as Integer
    val tiles = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("tiles")) as EList<EObject>
    val tileplacement = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("tileplacement")) as EList<EObject>
    // ???
    val legalMovePipeline = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("legalMovesPipeline")) as EList<EObject>
    val effectPipeline = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("effectPipeline")) as EList<EObject>
	


'''
Board(
	width=Â«widthÂ»,
	height=Â«heightÂ»,
	checkered=Â«checkeredÂ»,
	size=Â«sizeÂ»,
	tiles = [
	Â«FOR tile : tilesÂ»
	Â«generateTile(tile)Â»
	Â«ENDFORÂ»
	]
	tileplacement = [
	Â«FOR tile : tileplacementÂ»
	Â«generateTileplacement(tile)Â»
	Â«ENDFORÂ»
]
)
'''

}

// State Machine Start

def generateTile(EObject tile) {
	val name = tile.eGet(tile.eClass.getEStructuralFeature("name")) as String
    val type = tile.eGet(tile.eClass.getEStructuralFeature("type")) as String
    val hexColor = tile.eGet(tile.eClass.getEStructuralFeature("hexColor")) as String
    val initialState = tile.eGet(tile.eClass.getEStructuralFeature("initialState")) as EObject
    val states = tile.eGet(tile.eClass.getEStructuralFeature("states")) as EList<EObject>
    val transitions = tile.eGet(tile.eClass.getEStructuralFeature("transitions")) as EList<EObject>
    
'''
Tile(
    name="Â«nameÂ»",
    type="Â«typeÂ»",
    hexColor="Â«hexColorÂ»",
    initialState=Â«IF initialState !== nullÂ»Â«generateState(initialState)Â»Â«ELSEÂ»NoneÂ«ENDIFÂ»,
    states=[
        Â«FOR state : states SEPARATOR ","Â»
            Â«generateState(state)Â»
        Â«ENDFORÂ»
    ],
    transitions=[
        Â«FOR transition : transitions SEPARATOR ","Â»
            Â«generateTransition(transition)Â»
        Â«ENDFORÂ»
    ]
)'''
}

def generateState(EObject state) { 
	val outbound = state.eGet(state.eClass.getEStructuralFeature("outbound")) as EList<EObject> // hjelp her andreas
	val inbound = state.eGet(state.eClass.getEStructuralFeature("inbound")) as EList<EObject>
	val name = state.eGet(state.eClass.getEStructuralFeature("name")) as String
	val hexColor = state.eGet(state.eClass.getEStructuralFeature("hexColor")) as String
	
'''
State(
    name=Â«IF name !== nullÂ»"Â«nameÂ»"Â«ELSEÂ»NoneÂ«ENDIFÂ»,
    hexColor="Â«hexColorÂ»",
    outbound=[
        Â«FOR transition : outboundÂ»
        Â«transition.eGet(transition.eClass.getEStructuralFeature("name"))Â»
        Â«ENDFORÂ»
        ],
    inbound=[
        Â«FOR transition : inboundÂ»
        Â«transition.eGet(transition.eClass.getEStructuralFeature("name"))Â»
        Â«ENDFORÂ»
        ]
)'''
	
}

def generateTransition(EObject transition) {
	val name = transition.eGet(transition.eClass.getEStructuralFeature("name")) as String
	val source = transition.eGet(transition.eClass.getEStructuralFeature("source")) as EList<EObject> // her og
	val target = transition.eGet(transition.eClass.getEStructuralFeature("target")) as EObject
	
'''
Transition(
	name=Â«IF name !== nullÂ»"Â«nameÂ»"Â«ELSEÂ»NoneÂ«ENDIFÂ»,
	source=[
	    Â«FOR state : sourceÂ»
	    Â«state.eGet(state.eClass.getEStructuralFeature("name"))Â»
	    Â«ENDFORÂ»
	    ],
	target=Â«target.eGet(target.eClass.getEStructuralFeature("name"))Â»
'''
}
	
// State Machine End

// Tile Placement
def generateTileplacement(EObject tileplacement) {
	val tile = tileplacement.eGet(tileplacement.eClass.getEStructuralFeature("tile")) as EObject
	val row = tileplacement.eGet(tileplacement.eClass.getEStructuralFeature("row")) as Integer
	val column = tileplacement.eGet(tileplacement.eClass.getEStructuralFeature("column")) as Integer
	val darker = tileplacement.eGet(tileplacement.eClass.getEStructuralFeature("darker")) as Boolean
	val coordinate = tileplacement.eGet(tileplacement.eClass.getEStructuralFeature("coordinate")) as String
	
'''
Tileplacement(
	tile=Â«tile.eGet(tile.eClass.getEStructuralFeature("name")) as StringÂ»,,
	row=Â«rowÂ»,
	column=Â«columnÂ»,
	darker=Â«darkerÂ»,
	coordinate="Â«coordinateÂ»"
)
'''
}

def toPythonFieldDec(EStructuralFeature field) {
	val typeStr = field.pythonTypeString
	if (field.many) {
		'''	Â«field.nameÂ»: List["Â«typeStrÂ»"] = []'''
	} else {
		if (field.lowerBound == 0) {
			'''	Â«field.nameÂ»: Optional["Â«typeStrÂ»"] = None'''
		} else {
			'''	Â«field.nameÂ»: "Â«typeStrÂ»"'''
		}
	}
}

def pythonTypeString(EStructuralFeature field) {
	switch field {
		EAttribute: {
			val icn = field.EAttributeType.instanceClassName
                if (icn == "int" || icn == "java.lang.Integer") {
                    "int"
                } else if (icn == "boolean" || icn == "java.lang.Boolean") {
                    "bool"
                } else {
                    // default to string (also covers enums for now)
                    "str"
                }
		}
		EReference: {
			val refType = (field as EReference).EReferenceType
			refType.name
		}
		default: "str"
	}
}


	
	def compileStructural(EClass c) 
'''
		class Â«c.nameÂ»:
			def __init__(self, **kwargs):
			Â«FOR feature : c.EAllStructuralFeaturesÂ»
				self.Â«feature.nameÂ» = kwargs.get("Â«feature.nameÂ»", Â«feature.compileInitializationÂ»)
			Â«ENDFORÂ»

			def __str__(self):
				return "Instance of Â«c.nameÂ»"
'''

	def compileWithData(EObject instance) {
	        
	        val eClass = instance.eClass as EClass 
	        
	        // ðŸš¨ DATA EXTRACTION ðŸš¨
	        // 1. Find the EStructuralFeatures for 'width' and 'height'
	        val nameFeature = eClass.EStructuralFeatures.findFirst[name == "name"]
	        
	        // 2. Extract the actual values from the instance object
	        val name = instance.eGet(nameFeature) as String
	        
	'''
	class Â«eClass.nameÂ»:
	
		# Data pulled directly from the textual model instance and hardcoded
		name = Â«nameÂ»
		
		def __init__(self):
			self.name = name
	
		def __str__(self):
			return "Game with name Â«nameÂ»"
	'''
	
	
	}

def compileInitialization(EStructuralFeature feature) {
        if (feature.isMany) {
            '[]'
        } else {
            'None'
        }
    }
}
