/*
 * generated by Xtext 2.39.0
 */
package no.ntnu.tdt4250.bg.bgdsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EStructuralFeature
import java.util.Set
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BgDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		//val models = resource.allCSontents
		
		val gameInstance = resource.contents.head as EObject
		val gameEClass = gameInstance.eClass
		
		val allUniqueEClasses = gameInstance.eAllContents.toIterable.map[eClass].toSet
		
		allUniqueEClasses.add(gameEClass)
        
        if (gameInstance === null) {
            System.err.println("Model resource is empty. Cannot generate data.")
            return;
        }
        
        System.out.println("Generating code with model instance data...")
        
        // 1a. Generate the Board file (Data-Specific)
        fsa.generateFile(
            "models" + ".py",
            allUniqueEClasses.compileModels(gameInstance)
        )
        
        // 1b. Generate all other structural classes (e.g., Tile)
        // Filter out the Board class and generate the structural blueprints.
        /*for (eClass : allUniqueEClasses.filter[it != gameEClass]) {
            fsa.generateFile(
                eClass.name + ".py",
                eClass.compileStructural
            )
        }*/
        
  
	}
	
	def compileModels(Set<EClass> models, EObject gameInstance)
'''
from typing import List, Optional
from pydantic import BaseModel

Â«FOR model : modelsÂ»
class Â«model.nameÂ»(BaseModel):
	Â«IF model.EAllStructuralFeatures.emptyÂ»
	pass
	Â«ELSEÂ»
	Â«FOR field : model.EAllStructuralFeaturesÂ»
Â«field.toPythonFieldDecÂ»
	Â«ENDFORÂ»
	Â«ENDIFÂ»

Â«ENDFORÂ»
Â«FOR model : modelsÂ»
Â«model.nameÂ».model_rebuild()
Â«ENDFORÂ»
Â«initializeValues(gameInstance)Â»
'''


def initializeValues(EObject gameInstance) {
	val boardInstance = gameInstance.eGet(gameInstance.eClass.getEStructuralFeature("board")) as EObject
	val width = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("width")) as Integer
	val height = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("height")) as Integer
	
	val tiles = boardInstance.eGet(boardInstance.eClass.getEStructuralFeature("tiles"))	as EList<EObject>
'''
tiles = [
Â«FOR tile : tilesÂ»
Tile(Â«tile.eGet(tile.eClass.getEStructuralFeature("name"))Â»)
Â«ENDFORÂ»
]
'''
}
def toPythonFieldDec(EStructuralFeature field) {
	val typeStr = field.pythonTypeString
	if (field.many) {
		'''	Â«field.nameÂ»: List["Â«typeStrÂ»"] = []'''
	} else {
		if (field.lowerBound == 0) {
			'''	Â«field.nameÂ»: Optional["Â«typeStrÂ»"] = None'''
		} else {
			'''	Â«field.nameÂ»: "Â«typeStrÂ»"'''
		}
	}
}

def pythonTypeString(EStructuralFeature field) {
	switch field {
		EAttribute: {
			val icn = field.EAttributeType.instanceClassName
                if (icn == "int" || icn == "java.lang.Integer") {
                    "int"
                } else if (icn == "boolean" || icn == "java.lang.Boolean") {
                    "bool"
                } else {
                    // default to string (also covers enums for now)
                    "str"
                }
		}
		EReference: {
			val refType = (field as EReference).EReferenceType
			refType.name
		}
		default: "str"
	}
}


	
	def compileStructural(EClass c) 
'''
		class Â«c.nameÂ»:
			def __init__(self, **kwargs):
			Â«FOR feature : c.EAllStructuralFeaturesÂ»
				self.Â«feature.nameÂ» = kwargs.get("Â«feature.nameÂ»", Â«feature.compileInitializationÂ»)
			Â«ENDFORÂ»

			def __str__(self):
				return "Instance of Â«c.nameÂ»"
'''

	def compileWithData(EObject instance) {
	        
	        val eClass = instance.eClass as EClass 
	        
	        // ðŸš¨ DATA EXTRACTION ðŸš¨
	        // 1. Find the EStructuralFeatures for 'width' and 'height'
	        val nameFeature = eClass.EStructuralFeatures.findFirst[name == "name"]
	        
	        // 2. Extract the actual values from the instance object
	        val name = instance.eGet(nameFeature) as String
	        
	'''
	class Â«eClass.nameÂ»:
	
		# Data pulled directly from the textual model instance and hardcoded
		name = Â«nameÂ»
		
		def __init__(self):
			self.name = name
	
		def __str__(self):
			return "Game with name Â«nameÂ»"
	'''
	
	
	}

def compileInitialization(EStructuralFeature feature) {
        if (feature.isMany) {
            '[]'
        } else {
            'None'
        }
    }
}
